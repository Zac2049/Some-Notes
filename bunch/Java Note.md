# Java Note

## Java基础

1. 命名规则：包小写、类驼峰、其他首单词小写其余驼峰。
   
2. ==只能判断两个是否管理同一个对象，equals才能判断两个对象内容是否相同。

3. 访问属性

   * **public** 任何都可以访问。
   * **friendly** 类或属性不加任何限定，只有package内才可访问。
   * **private** 仅允许类内方法和属性相互访问（类内并不包括子类）。是类的概念，同一类的不同对象可访问其私有成员。

4. 包

   * 一个Java文件就是一个编译单元，一个目录下的所有Java文件为一个包，当需要用到的类不在一个包时，需要import对应的包。

   * `import <package名>.<类名>`或者``import <package名>.*`星号为通配符。

     或者只import包，具体使用其中的类。

   * 每一个`.`实际是一个Java包的文件层次。

5. 类中的static变量，称为类变量（属性），可通过`类.变量`来访问，所有对象共享这个变量，初始化只有一次。

   类中的static函数，称为类函数（方法），可通过`类.函数`或者`函数`来访问，所有对象共享这个函数。

6. 对象数组的声明如`String[] a = new String[10]`之后还需要进一步初始化，如for循环赋值，对每一个进行`a[i] =new String()`，因为对象只是数据的管理者，类似指针，不是其真正的拥有者。

7. 继承关系中，父类的private变量子类并不可见，改进方法：

   * private改成protected，**被 protected 修饰的成员对于本包和其子类可见**。实际上，protected的可见性在于两点：

     > - 基类的 protected 成员是包内可见的，并且对子类可见；
     > - 若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。

   * 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。

     如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器。

   **super**关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。用法：

   * `super(args)`传参（需要在父类进行构造的private变量）进行构造
   * `super.func()`调用父类的private函数

8. 子类的对象可以赋值给父类的变量，即**向上造型**（注意：Java中不存在对象对对象的赋值），具体可以表现在=号赋值，或者传对象形式。

   父类的对象不能赋值给子类的对象，需要使用**造型**（Cast）来实现，和**转换**区别在于，造型是将对象当作所需对象看待，实际不会改变其内容，而转换往往会改变变量中的值。

   ```java
   Vechicle v;
   Car c = new Car();
   v = c;//可以
   c = v;//不行，编译错误
   c = (Car)v;//向下造型
   ```

9. 通过对象变量调用函数的时候，调用哪个函数这件事称作**绑定**。

   * 静态绑定：根据变量的声明类型来决定。
   * 动态绑定：根据变量的动态声明来决定。

   在成员函数中调用其他成员函数也是通过this这个对象变量来调用的。

   Java中只能用动态绑定，如父类函数中根据使用的对象类型对子类函数进行调用，进一步，子类会将和父类相同名和参数的函数做**覆盖**（override）。

10. <img src="C:\Users\zacbi\AppData\Roaming\Typora\typora-user-images\image-20210122205737055.png" alt="image-20210122205737055" style="zoom: 25%;" />

11. 用封装降低耦合，用容器而不是单个变量实现可拓展性-----见翁恺视频

12. 抽象函数——表达概念而无法实现具体代码的函数

    抽象类——表达概念而无法构造出实体的类

    用abstract修饰函数和类，有抽象函数的类必是抽象类，其无对象，但可定义变量，任何继承了抽象类的非抽象类的对象可付给这个变量（即任何子类的对象都可由这个变量来管理）。

    继承自抽象类的子类必须覆盖父类中的抽象函数，否则自己就成为抽象类。

13. <img src="C:\Users\zacbi\AppData\Roaming\Typora\typora-user-images\image-20210123220951390.png" alt="image-20210123220951390" style="zoom: 25%;" />

    异常从内向外（按照括号和控制流）寻找是否和给出的catch中的异常类相匹配。

    `e.getMessage()`异常类名，`e.printStackTrace()`函数调用到发生异常处的trace。

    catch捕捉到异常后，可选择throw重新抛出。

14. <img src="C:\Users\zacbi\AppData\Roaming\Typora\typora-user-images\image-20210123222509279.png" alt="image-20210123222509279" style="zoom:25%;" />

15. 异常声明遇到继承关系

    * 当覆盖一个函数时，子类不能声明抛出比父类的版本更多的异常
    * 在子类的构造函数中，必须声明父类可能抛出的全部异常

16. 流（stream）一维性、单向性

17. <img src="C:\Users\zacbi\AppData\Roaming\Typora\typora-user-images\image-20210124234457851.png" alt="image-20210124234457851" style="zoom:25%;" />