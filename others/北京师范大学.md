一，选择题（选择题一共10题）（题目以及顺序不一定完全符合，毕竟回忆版）

1，小题好像是给栈的输入与输出序列，让你选push与pop组合

2，双链表在p之前插入

3，考压缩矩阵，问矩阵元素在数组的坐标

4，删除堆元素的复杂度（这个我没拿准，蒙了个，下来对答案错了，惨惨）

5，有向无环图与有换图中错误的说法

6，考后序表达式

9，考hash表冲突，再散列法处理后的结果

10，考一个只有一个元素是逆序的，选哪个排序方法比较次数最少，选项有简单选择，快排，直接插入，冒泡排序 

二，填空题（也是10道题）感觉也都是做过的比如说

1，稀疏矩阵的压缩处理方法,

2，带头结点与不带头结点的单链表判断为空,

3，哈夫曼树h高度的最少个数结点与最大个数结点,

4，广义表的操作，

5，考折半查找的比较次数，

6，给你一个排序过程，判断是什么排序，明眼一看就是快排

7，出度入度与边数关系 

三，判断题（也是10题）有些题历年考题有：比如时间复杂度，判断邻接矩阵存储图的大小与什么有关

四，简答题

1， 给了三段代码，有关栈与队列的，让你分别说出它们的功能是什么

2， 广义表的链式表示，说广度与深度

3， 给你一串数字，两个小问：一个让你排二叉排序树，然后算平均查找成功长度；第二小问：让你排一个平衡排序二叉树，后面也是算平均查找长度

4， 考AOE图，第一小问是拓扑排序，第二小问是从V1到V8的最短路径，第三小问是关键路径，算E，L，ve，vl

5， 建立平衡二叉树，不平衡了怎么办

6， 给个B树，一直插入元素，再分裂

7， 考shell排序，快排，堆排序

五、程序设计题

让你设计二叉树中序遍历的递归与非递归算法，打印结点中序序列

今年考上的话继续回来更新

***

多组测试数据，每组测试数据给出不超过1000颗树n（即算法时间复杂度为小于O(n^2)才能过）并且第二行给出每棵树的高度，初始时相邻两颗树距离都相等，需要砍掉最少的树使得这些树高度呈现非递减的序列并且相邻树之间距离要相等，输出最少砍的树的数目。

例如：1,6,2,3,5；砍掉第1, ,2, ,5这样每棵相邻的树距离都间隔2个单位相等并且为非递减序列；或者砍掉第1,2棵树变为 , ,2,3,5这样每棵相邻的树距离都间隔1个单位相等并且为非递减序列，该序列需要砍掉最少的树为2。
思路：当时这题没做出来，开始看错题以为是最长上升子序列，后来最后才做这一题，该题容易想到对树的距离从1到1000进行枚举对每棵树的每种距离进行判断，但是它的时间复杂度为O(n^2logn)，但是题目多组数据卡了时间复杂度只能O(n^2)过 时间不够来不及优化比赛就结束了。赛后才想到dp(i)(j)的转移方程为第i个位置向前判断j个距离，每次只要对前位置i和i-j比较，当前i位置树高度大于等于i-j位置，那么dp(i)(j)=dp(i-j)(j)这样转移下去就可得到答案且时间复杂度为O(n^2)。

***

题型如下：

填空（3‘*10），论述题（15’*2），计算题（20’*1）算法设计(20’*1)

填空题考了大概以下几个题目

> \1.  内存的最小单位，1K=____这个单位
>
> \2.  主存129号单元映射到四路组相联那一块
>
> \3.  高度为6的平衡二叉树有多少结点
>
> \4.  顶点为7的连通图最少多少条边
>
> \5.  冒泡排序第三趟结果
>
> \6.  -2017的补码

论述题：

> \1.  虚拟存储器的作用及原理
>
> \2.  简述线性表、栈、队列的定义，举例它们的应用。

计算题：

> 组成原理的一道计算题，第一小问是求MIPS，第二小问是求Cache缺失多少，第三小问是求主存的速度。

算法题

> 求链表的倒数第k个元素（王道原题）

复习建议

> 刷王道的组成原理，我刷了大概8遍题目，基本上专业课都写起来了吧。
>
> 以上考完以后，开始写**文献综述**。
>
> 给你十篇全英文文章，你任意选一个，然后自己做PPT。
>
> 十篇文章大概有关于5G的，有关于人工只能的，并且篇幅也不一样长，有的好像12页，我选的比较短的，只有4页。是一篇关于人工智能在医疗领域的应用。PPT做完以后给老师拷到U盘上午就结束了。

***

 （原题考点大数除法，替换为PAT乙级1017）本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。

#### 输入格式： 

  输入在一行中依次给出 A 和 B，中间以 1 空格分隔。

#### 输出格式：

  在一行中依次输出 Q 和 R，中间以 1 空格分隔。

#### 输入样例：

```
123456789050987654321 7
```

0123 2

**输出样例：**

```
17636684150141093474 3
```

61 1

##### 解决方法：

```c++
#include <algorithm>
#include <iostream>
#include <math.h>
#include <string>
#include <vector>
using namespace std;

int main()
{
    string s;
    int d;
    cin >> s >> d;
    string res;
    int qu, re = 0; //qu为商、re为余数
    bool flag = false; //商是否出现非0位，是为true,商一直为0，则一直为false，一直continue
    for (int i = 0; i < (int)s.size(); i++) {
        re = re * 10 + s[i] - '0';//核心
        qu = re / d;
        re = re % d;             
        if ((qu == 0) && !flag) {
            continue;
        }
        res += to_string(qu);
        flag = true;
    }
    if (!flag) { //商为0的情况
        cout << "0 " << re;
    } else {
        cout << res << " " << re << endl;
    }
    system("pause");
    return 0;
}
```

 多组测试用例，每组测试用例给出不超过1000棵树，并且第二行给出每棵树的高度，初始时，相邻两个树的距离都相等，需要砍掉最少的树使得这些树高度呈现非递减的序列并且相邻树之间距离要相等，输出最少砍的树的数目。

#### 输入格式： 

  输入树的棵数n，然后在接下来的一行输入n个正整数表示树的高度，整数之间以空格为间隔。

#### 输出格式：

  最少砍掉的树的棵数。

#### 输入样例：

```
6 6 5 4 3 2 1
```

10
1 9 2 8 3 2 4 6 5 2

5
1 2 6 2 4 

**输出样例：**

```
5
```

5

2

```c++
#include <algorithm>
#include <iostream>
#include <math.h>
#include <string>
#include <vector>
using namespace std;
//公众号：一航代码
int main()
{
    int n;
    cin >> n;                                     //若oj需要循环输入，此处须用循环
    vector<int> v(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
    }

    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 1));
    for (int i = n; i >= 1; i--) {                 //d[i][j]表示第i棵树间隔j个距离，值表示非递减序列的长度
        for (int j = 1; j <= n; j++) {             //从第n棵树，依次向前遍历 
            if ((i - j) >= 1 && v[i] >= v[i - j]) {//遍历与第i棵树，距离为j个单位的树，如果第i-j棵树的高度比第i棵树小则更新dp数组
                dp[i - j][j] = dp[i][j] + 1;
            }
        }
    }
    int max_tree = 1;
    // int index,gap;
    max_tree = dp[1][1];
    for (int i = 1; i <= n; i++) {                  //取dp数组中的最大值max_tree，即为最长非递减序列的长度
        for (int j = 1; j <= n; j++) {              //if中可添加标记，index为序列起点，gap为间隔
            if (max_tree <= dp[i][j]) {             //这里添加了等号，如果有多种情况，仅保留最后一个最大值
                max_tree = dp[i][j];                //也可以定义一个res数组保存多种情况下的序列
                // index = i;
                // gap = j;
            }
        }
    }

    cout << n - max_tree << endl;                   //砍掉的树为n-max_tree
    system("pause");
    return 0;
}
```

![img](http://www.cskaoyan.com/forum.php?mod=attachment&aid=MzY4NTR8ZTliMDVhODR8MTYxMTMyNDEyMHw1MjI4NzF8NjU0MDQy&noupdate=yes)

1.a+b(送分)
2.n种商品价格不一样，有m元，最多可以买几个(送分)
3.判断一个超大数n是否能被k整除(要想一会儿)
4.逆序数交换次数(没思路)
5.砍树，一排树要求从低到高，问最少砍几棵树，要求树间距一样(没思路)
6.驼峰命名法转下划线命名法(情况多比较麻烦)
7.队列题，给出一系列入队/出队+人名，问有几个人插队(一直超时QAQ)

开始讲综述，我讲了5分钟，问我有没有科研经历，做过什么项目，一句话概括刚才的综述，为什么要考研，今后打算在在什么领域研究，说说图形学将来的发展，说说本科阶段研究过什么用来解决人工智能的数学模型，人工智能将怎样发展，如果研究生阶段遇到一些无法逾越的困难怎么办，本科期间有什么让我无法放弃的事，图形和图像的区别，担任过什么职务。最后英语回答，介绍本科期间最喜欢的一门课(一脸懵逼，然后我说的经济学，尴尬)。整个面试过程不太流畅，可能老师们还没准备好。。。我表现的应该还算积极乐观，虽然我什么都不会233

***

复试科目：
计算机体系结构加数据结构：主要考了一些组成原理的知识，操作系统考到了一些，但是涉及到的不多。组成原理考到了补码计算、虚拟存储器（这个操作系统讲的详细一些）、一些关于计算机性能的计算题（MIPS、主频这些）、cache。数据结构考到了平衡二叉树、栈，有一道简答题是要求介绍栈、队列、线性表，并举例说明其应用。最后有一道编程题，题目是寻找不知道链表节点总数的链表的倒数第k个结点，我记得这道题好像在天勤的书上看到过。我复试还是用的天勤的书，组成原理的一些计算感觉讲得很清楚，还有一些疑问解答。（老板又打了一次广告……）

专业英语：考察了一些专业名词的汉译英、英译汉，记得有什么信号处理、计算机网络等等。还有一段关于人工智能的英文，翻译成为汉语。最后是一段关于计算机各个组成部件的中文，要求翻译成为英文。

面试：今年面试新增加了一个环节就是要讲PPT，这个PPT是上午笔试交卷之后做的。上午笔试+PPT一共3个小时，感觉时间还是有点紧。要求在10篇英文文章当中选出来一篇，做成PPT，PPT可用英文可用中文，下午面试的时候给面试官讲。其余的跟去年的面试环节类似。面试官没有让我用英文自我介绍，也没有让我用英文介绍我的家乡。因为我之前工作过，所以他们让我用英语介绍一下我之前工作过的公司做的APP。